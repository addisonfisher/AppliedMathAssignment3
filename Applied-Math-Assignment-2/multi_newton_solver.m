%Your Implementation of Newton's method
%INPUTS:
%fun: the mathematical function for which we want to compute the root
% note that the output of fun may include the derivative
% i.e. [fval,dfdx] = fun(x)
% or not, i.e. fval = fun(x)
%x_guess the initial guess for Newton's method
%solver_params: a MATLAB struct containing solver settings
% solver_params.dxtol: terminate early if |x_{i+1}-x_{i}|<dxtol
% solver_params.ftol: terminate early if |f(x_i)|<ftol
% solver_params.dxmax: terminate early if |x_{i+1}-x_{i}|>dxmax
% (meaning that jacobian is probably singular, which is bad)
% solver_params.numerical_diff: boolean (0 or 1)
% 1-> numerically differentiate, 0-> use analytical derivative
%should use numerical differentation to compute the Jacobian or
%use a Jacobian generated by fun. No input assumes numerical by default
% true->fun is assumed to return [fval,J]
% false->fun is assumed to only return fval
%OUTPUTS:
%x: the estimate of the root computed by the function
% exit_flag: an integer indicating whether or not the solver succeeded
function [x, exit_flag, num_evals] = multi_newton_solver(fun,x_guess,solver_params)
    %unpack values from struct (if fields in struct have been set)
    num_evals = 0;
    dxtol = 1e-14;
    if isfield(solver_params,'dxtol')
        dxtol = solver_params.dxtol;
    end
    ftol = 1e-14;
    if isfield(solver_params,'ftol')
        ftol = solver_params.ftol;
    end
    dxmax = 1e8;
    if isfield(solver_params,'dxmax')
        dxmax = solver_params.dxmax;
    end
    numerical_diff = 1;
    if isfield(solver_params,'numerical_diff')
        numerical_diff = solver_params.numerical_diff;
    end
    
    X = x_guess;
    % max_iter = 200;
    exit_flag = 0;

    dxmin = solver_params.dxmin;
    ftol = solver_params.ftol;
    dxmax = solver_params.dxmax;
    max_iter = solver_params.maxiter;
    approx = solver_params.approx;


    if approx
        fval = fun(X);        
        [J, jacobian_evals] = approx_jacobian01(fun, X);
        num_evals = num_evals + 1 + jacobian_evals;

    else
        [fval,J] = fun(X);
        num_evals = num_evals + 1;
    end

    delta_x = -J\fval;

    count = 0;

    while count<max_iter && norm(delta_x)>dxmin && norm(fval) > ftol && norm(delta_x)<dxmax
        count = count+1;

        if approx
        fval = fun(X);
        [J, jacobian_evals] = approx_jacobian01(fun, X);
        num_evals = num_evals + 1 + jacobian_evals;
        else
        [fval,J] = fun(X);
        num_evals = num_evals + 1;
        end

        delta_x = -J\fval;

        X = X + delta_x;

    end
    xroot = X;
    %disp(xroot)
    
    if count==max_iter
        exit_flag = 1;
    end
    
    % for i = 1:max_iter
    %     if numerical_diff == 1
    %         %numerical differentiation
    %         f_val = fun(x);
    %         J = approximate_jacobian(fun, x);
    %     else
    %         %analytical provided by function
    %         [f_val, J] = fun(x);
    %     end
    % 
    %     % early termination check
    %     if norm(f_val) < ftol
    %         exit_flag = 0;
    %         break;
    %     end
    % 
    %     %check if jacobian is singular
    %     if det(J'*J) < 1e-14
    %         exit_flag = -1;
    %         break;
    %     end
    % 
    %     %calc step
    %     delta_X = J \ -f_val;
    %     x = x + delta_X;
    % 
    %     %chek step size
    %     if norm(delta_X) < dxtol
    %         exit_flag = 0;
    %         break;
    %     end
    % end

    if exit_flag == 1
        warning('Max iter reach without converging.');
    elseif exit_flag == -1
        warning('Jacobian is singular or incorrect size.')
    end
    x = xroot;
end



function [J, num_evals] = approx_jacobian01(fun,X)

    f0 = fun(X);
    J = zeros(length(f0), length(X));


    e_n = zeros(length(X),1);

    delta_X = 1e-6;

    for n = 1:length(X)
        e_n(n) = 1;


        f_plus = fun(X+e_n*delta_X);
        f_minus = fun(X-e_n*delta_X);

        J(:,n) = (f_plus-f_minus) / (2*delta_X);

        e_n(n) = 0;
    end
    num_evals = 2 * length(X);

end

% function [fval, J] = test_function_01(X)
%     x1 = X(1); x2 = X(2); x3 = X(3);
% 
% 
%     f1 = x1^2 + x2^2 - 6 + x3^5;
%     f2 = x1*x3 + x2 -12;
%     f3 = sin(x1 + x2 + x3);
% 
% 
% 
% 
%     fval = [f1;f2;f3];
% 
%     J = [ [2*x1, 2*x2, -5*x3^4];...
%         [x3, 1, x1];...
%         [cos(x1+x2+x3),cos(x1+x2+x3),cos(x1+x2+x3)]];
% end